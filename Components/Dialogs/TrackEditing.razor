@using Ongaku.Models
@inject Ongaku.Services.TrackService TrackService
@inject Ongaku.Services.ArtistService ArtistService
@inject ISnackbar Snackbar

<MudDialog>
	<TitleContent>Editing @track.Title</TitleContent>
	<DialogContent>
		<MudStack Style="width: 100%;" Class="d-flex flex-column gap-4 align-center">
			<MudFileUpload T="IBrowserFile"
				  FilesChanged="UploadCover"
				  Accept=".png, .jpg, .webp, .jpeg" >
				<ActivatorContent>
					<div class="d-flex flex-column gap-2">
						<MudImage Width="300" Height="300" Class="rounded-lg interactive-border" ObjectFit="ObjectFit.Cover"
								  Src="@(previewImage ?? track.CoverPath)" FallbackSrc="assets/teto_cover.png" />
					</div>
				</ActivatorContent>
			</MudFileUpload>

			<MudTextField Style="width: 80%; min-width: 20rem;" Label="Title" @bind-Value="@_title" Variant="Variant.Outlined"/>

			<MudAutocomplete T="string" Style="width: 80%; min-width: 20rem;" Label="Artist"
							 @bind-Value="@_artist" Variant="Variant.Outlined" 
							 SearchFunc="searchArtist" ResetValueOnEmptyText="true"
							 />

		</MudStack>
	</DialogContent>
	<DialogActions>
		<MudToolBar Gutters="true" Class="relative d-flex justify-end gap-4">
			<MudButton Color="Color.Secondary" Variant="Variant.Filled" @onclick="SaveChanges" >
				@if (_proccessing)
				{
					<MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
					<MudText Class="ms-2">Processing</MudText>
				}
				else
				{
					<MudText>
						Save
					</MudText>
				}
			</MudButton>
			<MudButton Color="Color.Error" Variant="Variant.Filled" @onclick="CloseDialog" >
				Cancel
			</MudButton>
		</MudToolBar>
	</DialogActions>
</MudDialog>

@code {
	[CascadingParameter]
	private IMudDialogInstance? MudDialog { get; set; }

	[Parameter]
	public required Track track { get; set; }

	private string _title = "";
	private string? _artist;

	private IBrowserFile? selectedCover;
	private string? previewImage;

	private bool _proccessing = false;

	protected override void OnParametersSet()
	{
		_title = track.Title;
		_artist = track.Artist.Name;
	}

	private async Task UploadCover(IBrowserFile file)
	{
		selectedCover = file;

		using var stream = selectedCover.OpenReadStream(long.MaxValue);
		var buffer = new byte[selectedCover.Size];
		await stream.ReadAsync(buffer);

		previewImage = $"data:{selectedCover.ContentType};base64,{Convert.ToBase64String(buffer)}";
	}

	private async Task SaveChanges()
	{
		_proccessing = true;

		if (selectedCover != null)
		{
			await TrackService.ChangeCoverAsync(selectedCover, track);
			selectedCover = null;
			previewImage = null;
		}

		if (_title != track.Title)
		{
			await TrackService.ChangeTitleAsync(_title, track);
			_title = "";
		}

		if (_artist != null && _artist != track.Artist.Name)
		{
			await TrackService.ChangeArtistAsync(_artist, track);
		}

		_proccessing = false;
		Snackbar.Add("Changes successfuly changed!", Severity.Success);
		MudDialog!.Close(DialogResult.Ok(true));
	}

	private void CloseDialog()
	{
		MudDialog!.Close(DialogResult.Cancel());
	}

	private async Task<IEnumerable<string>> searchArtist(string req, CancellationToken token)
	{
		try
		{
			await Task.Delay(300, token);

			if (req.Trim() != "")
			{
				return (await ArtistService.GetAllArtistsByRequest(req)).Select(a => a.Name);

			}
			else
			{
				return (await ArtistService.GetAllArtists()).Select(a => a.Name);
			}
		}
		catch (TaskCanceledException)
		{
			return Enumerable.Empty<string>();
		}
	}
}
