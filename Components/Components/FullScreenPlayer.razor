@inject Ongaku.Services.AudioService AudioService
@inject Ongaku.Services.TrackService TrackService
@using Ongaku.Models
@inject IJSRuntime JS
@using System.Globalization
@using Ongaku.Interfaces
@inject ISnackbar Snackbar

@if (_track != null)
{
	<div class="full-screen-player-container @(_hidden ? "hidden" : "showed")">
		<div class="d-flex flex-row pa-3 flex-shrink-0">
			<MudSpacer />
			<MudIconButton Size="Size.Large" @onclick="OnHideClicked" Color="Color.Primary" Icon="@Icons.Material.Outlined.ExpandCircleDown" />
		</div>

		<div class="d-flex flex-1 flex-row align-start justify-space-around" style="max-height: 100%;">
			<div style="display: flex; align-items: center; justify-content: center; height: 100%; padding-bottom: 84px;">
				<div class="d-flex flex-column track-card-bg gap-3 ml-20">
					<div class="d-flex relative" style="border-radius: 1rem; overflow: hidden;">
						<MudImage Src="@_track.CoverPath" Width="450" Height="450" ObjectFit="ObjectFit.Cover"/>

						@if (_loading)
						{
							<div class="d-flex align-center justify-center" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7);">
								<MudProgressCircular Color="Color.Primary" Indeterminate Size="Size.Large" />
							</div>
						}
					</div>

					<div class="d-flex flex-column pa-1" style="max-width: 450px; overflow: hidden;">
						<MudText Class="track-title scrolling-text">@_track.Title</MudText>
						<MudText Class="artist-name scrolling-text">@_track.Artist.Name</MudText>
					</div>

					<MudSlider Step="0.001" Max="100" Min="0" Value="_time / _duration * 100" Color="Color.Primary" Rounded Size="Size.Medium" Variant="Variant.Filled"
							   ValueChanged="OnTimeChanged" Immediate T="double" Disabled="@(_loading ? true : false)" />

					<div class="d-flex flex-row justify-space-between mt-1" style="opacity: 0.8;">
						<MudText>@FormatTime(_time)</MudText>
						<MudText>@FormatTime(_duration)</MudText>
					</div>

					<div class="d-flex flex-row justify-space-between">
						<MudIconButton Icon="@(_shuffle? Icons.Material.Outlined.Shuffle : Icons.Material.Outlined.ArrowRightAlt)"
									   Color="Color.Primary"
									   Size="Size.Medium"
									   OnClick="@AudioService.ToggleShuffle" />

						<MudIconButton Icon="@Icons.Material.Outlined.SkipPrevious" Color="Color.Primary" @onclick="AudioService.PlayPrevAsync" />
						<MudFab Color="Color.Secondary" DropShadow="false" Size="Size.Large"
								@onclick="@(_paused? AudioService.ResumeAsync: AudioService.PauseAsync)"
								Disabled="@(_loading ? true : false)"
								StartIcon="@(_paused ? Icons.Material.Outlined.PlayArrow : Icons.Material.Outlined.Pause)" />
						<MudIconButton Icon="@Icons.Material.Outlined.SkipNext" Color="Color.Primary" @onclick="AudioService.PlayNextAsync" />

						<MudIconButton Icon="@GetQueueModeIcon()"
									   OnClick="ToggleQueueMode"
									   Color="Color.Primary"
									   Size="Size.Medium" />
					</div>
				</div>
			</div>

			@if (_queue != null)
			{
				<div class="d-flex flex-column queue-container">
					<div class="d-flex flex-column queue-list-container">
						<MudStack Class="pt-5" Row="false" Breakpoint="Breakpoint.None">
							@foreach (Track track in _queue)
							{
								var id = $"track-{track.Id}";
								@if (track.Id == _track.Id)
								{
									<MudText Class="on-current-track-info">сейчас играет <b style="color: #c59ae3;">@GetOnAQueueCurrentTrackInfo()</b></MudText>
								}

								<MudPaper id="@id" Class="track-item pa-4 d-flex flex-row justify-space-between align-center" Elevation="3" Outlined
										  Style="border-radius: 1rem; width: 100%;"
										  Height="5rem"
										  @onclick="() => AudioService.PlayAsync(track)">
									<div class="hover-panel d-flex justify-center align-center">
										<MudIcon Icon="@Icons.Material.Filled.PlayArrow" Size="Size.Large" Color="Color.Primary" />
									</div>

									<div class="d-flex flex-row align-center gap-3" style="width: 70%;">
										<MudImage Src="@track.CoverPath" FallbackSrc="assets/teto_cover.png" Class="z-10 rounded-lg"
												  Width="55" Height="55" ObjectFit="ObjectFit.Cover" />

										<div class="d-flex flex-column justify-center align-start" style="overflow: hidden; width: 70%;">
											<MudText style="font-size: 1.25rem; text-wrap: nowrap; z-index: 1;">@track.Title</MudText>
											<MudText style="font-size: 1rem; opacity: 0.7; text-wrap: nowrap; z-index: 1;">@track.Artist.Name</MudText>
										</div>
									</div>

									<div class="d-flex flex-row align-center">
										<MudText Class="z-10">@(track.Duration.Hours != 0 ? $"{track.Duration.Hours.ToString()}:" : "")@(track.Duration.Hours != 0 ? (track.Duration.Minutes.ToString().Length == 2 ? track.Duration.Minutes : "0" + track.Duration.Minutes) : track.Duration.Minutes):@(track.Duration.Seconds.ToString().Length == 1 ? "0" + track.Duration.Seconds : track.Duration.Seconds)</MudText>
										<Ongaku.Components.Buttons.TrackActionsBtn Track="@track" OnDelete="DeleteTrack" OnEdit="StateHasChanged" />
									</div>
								</MudPaper>

								@if (track.Id == _track.Id)
								{
									<div style="height: 2rem;" />
									<MudText class="pl-1 pr-1" Style="opacity: 0.8;">Далее в очереди</MudText>
								}
							}
						</MudStack>
					</div>
				</div>
			}
		</div>
	</div>
}

@code {
	[Parameter]
	public bool _hidden { get; set; }

	[Parameter]
	public EventCallback OnHide { get; set; }

	[Parameter]
	public Track? _track { get; set; }

	[Parameter]
	public bool _paused { get; set; }

	[Parameter]
	public double _time { get; set; }

	[Parameter]
	public double _duration { get; set; }

	[Parameter]
	public IReadOnlyList<Track>? _queue { get; set; }

	[Parameter]
	public bool _loading { get; set; }

	private bool _shuffle = false;
	private QueueModeEnum _queueMode = QueueModeEnum.Loop;

	protected override void OnInitialized()
	{
		_queueMode = AudioService.QueueMode;

		AudioService.OnQueueModeChanged += HandleQueueModeChanged;
		AudioService.OnShuffleStateChanged += HandleShuffleStateChanged;

		TrackService.OnTrackDelete += HandleTrackDelete;
	}

	private void HandleQueueModeChanged(QueueModeEnum newMode)
	{
		_queueMode = newMode;
		InvokeAsync(StateHasChanged);
	}

	private void HandleShuffleStateChanged(bool newShuffleState)
	{
		_shuffle = newShuffleState;
		InvokeAsync(StateHasChanged);
	}

	private void OnHideClicked()
	{
		OnHide.InvokeAsync();
	}

	protected override async Task OnParametersSetAsync()
	{
		if (!_hidden) await JS.InvokeVoidAsync("ongakuLockScroll");
		else await JS.InvokeVoidAsync("ongakuUnlockScroll");
	}

	private string FormatTime(double seconds)
	{
		int total = (int)Math.Floor(seconds);

		int h = total / 3600;
		int m = (total % 3600) / 60;
		int s = total % 60;

		if (h > 0)
			return $"{h}:{m:D2}:{s:D2}";

		return $"{m}:{s:D2}";
	}

	private string GetQueueModeIcon()
	{
		return _queueMode switch
		{
			QueueModeEnum.Loop => Icons.Material.Filled.Repeat,
			QueueModeEnum.LoopOne => Icons.Material.Filled.RepeatOne,
			QueueModeEnum.NoLoop => Icons.Material.Filled.RepeatOn,
			_ => Icons.Material.Filled.Repeat
		};
	}

	private void ToggleQueueMode()
	{
		switch (_queueMode)
		{
			case QueueModeEnum.Loop:
				_queueMode = QueueModeEnum.LoopOne;
				break;
			case QueueModeEnum.LoopOne:
				_queueMode = QueueModeEnum.NoLoop;
				break;
			case QueueModeEnum.NoLoop:
				_queueMode = QueueModeEnum.Loop;
				break;
			default:
				return;
		}

		AudioService.QueueMode = _queueMode;
		StateHasChanged();
	}

	private async void OnTimeChanged(double newTime)
	{
		if (_duration <= 0 || _track == null) return;

		double newCalcTime = newTime / 100 * _duration;

		await AudioService.SetTimeAsync(newCalcTime);

		StateHasChanged();
	}

	private void DeleteTrack(int id)
	{
		if (_queue == null) return;

		string name = _queue.FirstOrDefault(t => t.Id == id)!.Title;
		_queue = _queue.Where(t => t.Id != id).ToList();

		Snackbar.Add($"{name} successfuly deleted!", Severity.Success);
		StateHasChanged();
	}

	private string GetOnAQueueCurrentTrackInfo()
	{
		switch (AudioService.QueueSource)
		{
			case QueueSourceEnum.Library:
				return "БИБЛИОТЕКА";
			case QueueSourceEnum.Playlist:
				return $"плейлист {AudioService._currentPlaylistName}";
			case QueueSourceEnum.Artist:
				return $"артист {AudioService._currentArtistName}";
			case QueueSourceEnum.None:
				return "НИЧЕГО";
			default:
				return "неизвестно что..";
		}
	}

	private void HandleTrackDelete(Track track)
	{
		if (_queue != null && _queue.First(t => t.Id == track.Id) != null)
		{
			AudioService.Queue = AudioService.Queue?.Where(t => t.Id != track.Id).ToList();
			StateHasChanged();
		}
	}

	public void Dispose()
	{
		AudioService.OnQueueModeChanged -= HandleQueueModeChanged;
		AudioService.OnShuffleStateChanged -= HandleShuffleStateChanged;
	}
}
