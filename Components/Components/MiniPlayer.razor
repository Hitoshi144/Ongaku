@inject Ongaku.Services.AudioService AudioService
@inject Ongaku.Services.ViewportService ViewportService
@using Ongaku.Models
@inject ISnackbar Snackbar
@inject IDialogService Dialog

@if (_track != null && !_playerOpened)
{
	<div class="mini-player-container" @onclick="OpenPlayerAsync">
		<MudPaper class="mini-player-paper">
			<div class="progress-bar-container">
				<div class="progress-bar" style="--progress-bar-width: @_progress;" />

			</div>

			<div class="d-flex flex-row gap-3 align-center" style="max-width: 55%; overflow: clip; max-height: 100%;">
				<MudImage Src="@_track.CoverPath"
				Width="70" Height="70" ObjectFit="ObjectFit.Cover"
				Style="border-radius: 0.5rem; z-index: 2;"
				/>
				<div class="d-flex flex-column justify-center pt-3 pb-3">
					<MudText Style="text-wrap-mode: nowrap">
						@_track.Title
					</MudText>
					<MudText Style="opacity: 0.7; text-wrap-mode: nowrap;">
						@_track.Artist.Name
					</MudText>
				</div>
			</div>

			<div class="d-flex flex-row gap-2 align-center">
				@if (ViewportService.CurrentSize.Width > 768)
				{
					<div class="d-flex flex-row">
						<MudText>@FormatTime(_time)</MudText>
						<MudText>/</MudText>
						<MudText>@FormatTime(_duration)</MudText>
					</div>
				}

				<MudIconButton Icon="@Icons.Material.Outlined.SkipPrevious" Color="Color.Primary" />
				<MudFab Color="Color.Secondary"  Style="z-index: 2;" DropShadow="false"
				 @onclick="@(_paused ? AudioService.ResumeAsync : AudioService.PauseAsync)"
				 StartIcon="@(_paused ? Icons.Material.Outlined.PlayArrow : Icons.Material.Outlined.Pause)" />
				<MudIconButton Icon="@Icons.Material.Outlined.SkipNext" Color="Color.Primary" />
			</div>
		</MudPaper>
	</div>
}

@code {
	private Track? _track;
	private bool _paused;
	private double _time = 0;
	private double _duration = 0;
	private string _progress = "0%";
	private bool _playerOpened = false;

	protected override void OnInitialized()
	{
		base.OnInitialized();

		Action<Track> handleTrackChanged = HandleTrackChanged;
		AudioService.OnTrackChanged += handleTrackChanged;
		_track = AudioService.CurrentTrack;

		Action<bool> handlePauseStateChanged = HandlePauseStateChanged;
		AudioService.OnPauseStateChanged += handlePauseStateChanged;

		Action<double> handleTimeChanged = HandleTimeChanged;
		AudioService.OnTimeChanged += handleTimeChanged;

		Action<double> handleDurationChanged = HandleDurationChanged;
		AudioService.OnDurationChanged += handleDurationChanged;

		ViewportService.OnResize += HandleResize;
	}

	private void HandleTrackChanged(Track track)
	{
		_track = track;
		InvokeAsync(StateHasChanged);
	}

	private void HandlePauseStateChanged(bool state)
	{
		_paused = state;
		InvokeAsync(StateHasChanged);
	}

	private void HandleTimeChanged(double time)
	{
		_time = time;
		_progress = ((Math.Round(_time / _duration * 100, 2)).ToString() + "%").Replace(",", ".");
		InvokeAsync(StateHasChanged);
	}

	private void HandleDurationChanged(double duration)
	{
		_duration = duration;
		InvokeAsync(StateHasChanged);
	}

	private void HandleResize(BrowserWindowSize size)
	{
		InvokeAsync(StateHasChanged);
	}

	public void Dispose()
	{
		ViewportService.OnResize -= HandleResize;
	}

	private string FormatTime(double seconds)
	{
		int total = (int)Math.Floor(seconds);

		int h = total / 3600;
		int m = (total % 3600) / 60;
		int s = total % 60;

		if (h > 0)
			return $"{h}:{m:D2}:{s:D2}";

		return $"{m}:{s:D2}";
	}

	private async Task OpenPlayerAsync()
	{
		DialogOptions options = new() {FullScreen = true, CloseButton  = true };

		_playerOpened = true;
		StateHasChanged();

		var dialog = await Dialog.ShowAsync<FullScreenPlayer>("Player", options);
		var result = await dialog.Result;

		if (result != null)
		{
			_playerOpened = false;
			StateHasChanged();
		}
	}
}
